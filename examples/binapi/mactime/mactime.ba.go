// Code generated by GoVPP's binapi-generator. DO NOT EDIT.
// versions:
//  binapi-generator: v0.4.0-dev
//  VPP:              20.05-release
// source: /usr/share/vpp/api/plugins/mactime.api.json

/*
Package mactime contains generated code for VPP API file mactime.api (2.0.0).

It consists of:
	  2 aliases
	  6 enums
	  7 messages
	  2 types
*/
package mactime

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"net"
	"strconv"
	"strings"

	api "git.fd.io/govpp.git/api"
	codec "git.fd.io/govpp.git/codec"
	struc "github.com/lunixbochs/struc"

	interface_types "git.fd.io/govpp.git/examples/binapi/interface_types"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the GoVPP api package it is being compiled against.
// A compilation error at this line likely means your copy of the
// GoVPP api package needs to be updated.
const _ = api.GoVppAPIPackageIsVersion2 // please upgrade the GoVPP api package

const (
	// ModuleName is the name of this module.
	ModuleName = "mactime"
	// APIVersion is the API version of this module.
	APIVersion = "2.0.0"
	// VersionCrc is the CRC of this module.
	VersionCrc = 0x9283d3e
)

// MacAddress represents VPP binary API alias 'mac_address'.
type MacAddress [6]uint8

func ParseMAC(mac string) (parsed MacAddress, err error) {
	var hw net.HardwareAddr
	if hw, err = net.ParseMAC(mac); err != nil {
		return
	}
	copy(parsed[:], hw[:])
	return
}

func (m *MacAddress) ToString() string {
	return net.HardwareAddr(m[:]).String()
}

// MactimeTimeRange represents VPP binary API type 'mactime_time_range'.
type MactimeTimeRange struct {
	Start float64 `binapi:"f64,name=start" json:"start,omitempty"`
	End   float64 `binapi:"f64,name=end" json:"end,omitempty"`
}

func (*MactimeTimeRange) GetTypeName() string { return "mactime_time_range" }

// TimeRange represents VPP binary API type 'time_range'.
type TimeRange struct {
	Start float64 `binapi:"f64,name=start" json:"start,omitempty"`
	End   float64 `binapi:"f64,name=end" json:"end,omitempty"`
}

func (*TimeRange) GetTypeName() string { return "time_range" }

// MactimeAddDelRange represents VPP binary API message 'mactime_add_del_range'.
type MactimeAddDelRange struct {
	IsAdd      bool        `binapi:"bool,name=is_add" json:"is_add,omitempty"`
	Drop       bool        `binapi:"bool,name=drop" json:"drop,omitempty"`
	Allow      bool        `binapi:"bool,name=allow" json:"allow,omitempty"`
	AllowQuota uint8       `binapi:"u8,name=allow_quota" json:"allow_quota,omitempty"`
	NoUDP10001 bool        `binapi:"bool,name=no_udp_10001" json:"no_udp_10001,omitempty"`
	DataQuota  uint64      `binapi:"u64,name=data_quota" json:"data_quota,omitempty"`
	MacAddress MacAddress  `binapi:"mac_address,name=mac_address" json:"mac_address,omitempty"`
	DeviceName string      `binapi:"string[64],name=device_name" json:"device_name,omitempty" struc:"[64]byte"`
	Count      uint32      `binapi:"u32,name=count" json:"count,omitempty" struc:"sizeof=Ranges"`
	Ranges     []TimeRange `binapi:"time_range[count],name=ranges" json:"ranges,omitempty"`
}

func (m *MactimeAddDelRange) Reset()                        { *m = MactimeAddDelRange{} }
func (*MactimeAddDelRange) GetMessageName() string          { return "mactime_add_del_range" }
func (*MactimeAddDelRange) GetCrcString() string            { return "101858ef" }
func (*MactimeAddDelRange) GetMessageType() api.MessageType { return api.RequestMessage }

func (m *MactimeAddDelRange) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.IsAdd
	size += 1
	// field[1] m.Drop
	size += 1
	// field[1] m.Allow
	size += 1
	// field[1] m.AllowQuota
	size += 1
	// field[1] m.NoUDP10001
	size += 1
	// field[1] m.DataQuota
	size += 8
	// field[1] m.MacAddress
	size += 6
	// field[1] m.DeviceName
	size += 64
	// field[1] m.Count
	size += 4
	// field[1] m.Ranges
	for j1 := 0; j1 < len(m.Ranges); j1++ {
		var s1 TimeRange
		_ = s1
		if j1 < len(m.Ranges) {
			s1 = m.Ranges[j1]
		}
		// field[2] s1.Start
		size += 8
		// field[2] s1.End
		size += 8
	}
	return size
}
func (m *MactimeAddDelRange) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.IsAdd
	if m.IsAdd {
		buf[pos] = 1
	}
	pos += 1
	// field[1] m.Drop
	if m.Drop {
		buf[pos] = 1
	}
	pos += 1
	// field[1] m.Allow
	if m.Allow {
		buf[pos] = 1
	}
	pos += 1
	// field[1] m.AllowQuota
	buf[pos] = uint8(m.AllowQuota)
	pos += 1
	// field[1] m.NoUDP10001
	if m.NoUDP10001 {
		buf[pos] = 1
	}
	pos += 1
	// field[1] m.DataQuota
	o.PutUint64(buf[pos:pos+8], uint64(m.DataQuota))
	pos += 8
	// field[1] m.MacAddress
	for i := 0; i < 6; i++ {
		var x uint8
		if i < len(m.MacAddress) {
			x = uint8(m.MacAddress[i])
		}
		buf[pos] = uint8(x)
		pos += 1
	}
	// field[1] m.DeviceName
	copy(buf[pos:pos+64], m.DeviceName)
	pos += 64
	// field[1] m.Count
	o.PutUint32(buf[pos:pos+4], uint32(len(m.Ranges)))
	pos += 4
	// field[1] m.Ranges
	for j1 := 0; j1 < len(m.Ranges); j1++ {
		var v1 TimeRange
		if j1 < len(m.Ranges) {
			v1 = m.Ranges[j1]
		}
		// field[2] v1.Start
		o.PutUint64(buf[pos:pos+8], math.Float64bits(float64(v1.Start)))
		pos += 8
		// field[2] v1.End
		o.PutUint64(buf[pos:pos+8], math.Float64bits(float64(v1.End)))
		pos += 8
	}
	return buf, nil
}
func (m *MactimeAddDelRange) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.IsAdd
	m.IsAdd = tmp[pos] != 0
	pos += 1
	// field[1] m.Drop
	m.Drop = tmp[pos] != 0
	pos += 1
	// field[1] m.Allow
	m.Allow = tmp[pos] != 0
	pos += 1
	// field[1] m.AllowQuota
	m.AllowQuota = uint8(tmp[pos])
	pos += 1
	// field[1] m.NoUDP10001
	m.NoUDP10001 = tmp[pos] != 0
	pos += 1
	// field[1] m.DataQuota
	m.DataQuota = uint64(o.Uint64(tmp[pos : pos+8]))
	pos += 8
	// field[1] m.MacAddress
	for i := 0; i < len(m.MacAddress); i++ {
		m.MacAddress[i] = uint8(tmp[pos])
		pos += 1
	}
	// field[1] m.DeviceName
	{
		nul := bytes.Index(tmp[pos:pos+64], []byte{0x00})
		m.DeviceName = codec.DecodeString(tmp[pos : pos+nul])
		pos += 64
	}
	// field[1] m.Count
	m.Count = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	// field[1] m.Ranges
	m.Ranges = make([]TimeRange, int(m.Count))
	for j1 := 0; j1 < int(m.Count); j1++ {
		// field[2] m.Ranges[j1].Start
		m.Ranges[j1].Start = float64(math.Float64frombits(o.Uint64(tmp[pos : pos+8])))
		pos += 8
		// field[2] m.Ranges[j1].End
		m.Ranges[j1].End = float64(math.Float64frombits(o.Uint64(tmp[pos : pos+8])))
		pos += 8
	}
	return nil
}

// MactimeAddDelRangeReply represents VPP binary API message 'mactime_add_del_range_reply'.
type MactimeAddDelRangeReply struct {
	Retval int32 `binapi:"i32,name=retval" json:"retval,omitempty"`
}

func (m *MactimeAddDelRangeReply) Reset()                        { *m = MactimeAddDelRangeReply{} }
func (*MactimeAddDelRangeReply) GetMessageName() string          { return "mactime_add_del_range_reply" }
func (*MactimeAddDelRangeReply) GetCrcString() string            { return "e8d4e804" }
func (*MactimeAddDelRangeReply) GetMessageType() api.MessageType { return api.ReplyMessage }

func (m *MactimeAddDelRangeReply) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.Retval
	size += 4
	return size
}
func (m *MactimeAddDelRangeReply) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.Retval
	o.PutUint32(buf[pos:pos+4], uint32(m.Retval))
	pos += 4
	return buf, nil
}
func (m *MactimeAddDelRangeReply) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.Retval
	m.Retval = int32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	return nil
}

// MactimeDetails represents VPP binary API message 'mactime_details'.
type MactimeDetails struct {
	PoolIndex       uint32             `binapi:"u32,name=pool_index" json:"pool_index,omitempty"`
	MacAddress      MacAddress         `binapi:"mac_address,name=mac_address" json:"mac_address,omitempty"`
	DataQuota       uint64             `binapi:"u64,name=data_quota" json:"data_quota,omitempty"`
	DataUsedInRange uint64             `binapi:"u64,name=data_used_in_range" json:"data_used_in_range,omitempty"`
	Flags           uint32             `binapi:"u32,name=flags" json:"flags,omitempty"`
	DeviceName      string             `binapi:"string[64],name=device_name" json:"device_name,omitempty" struc:"[64]byte"`
	Nranges         uint32             `binapi:"u32,name=nranges" json:"nranges,omitempty" struc:"sizeof=Ranges"`
	Ranges          []MactimeTimeRange `binapi:"mactime_time_range[nranges],name=ranges" json:"ranges,omitempty"`
}

func (m *MactimeDetails) Reset()                        { *m = MactimeDetails{} }
func (*MactimeDetails) GetMessageName() string          { return "mactime_details" }
func (*MactimeDetails) GetCrcString() string            { return "44921c06" }
func (*MactimeDetails) GetMessageType() api.MessageType { return api.ReplyMessage }

func (m *MactimeDetails) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.PoolIndex
	size += 4
	// field[1] m.MacAddress
	size += 6
	// field[1] m.DataQuota
	size += 8
	// field[1] m.DataUsedInRange
	size += 8
	// field[1] m.Flags
	size += 4
	// field[1] m.DeviceName
	size += 64
	// field[1] m.Nranges
	size += 4
	// field[1] m.Ranges
	for j1 := 0; j1 < len(m.Ranges); j1++ {
		var s1 MactimeTimeRange
		_ = s1
		if j1 < len(m.Ranges) {
			s1 = m.Ranges[j1]
		}
		// field[2] s1.Start
		size += 8
		// field[2] s1.End
		size += 8
	}
	return size
}
func (m *MactimeDetails) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.PoolIndex
	o.PutUint32(buf[pos:pos+4], uint32(m.PoolIndex))
	pos += 4
	// field[1] m.MacAddress
	for i := 0; i < 6; i++ {
		var x uint8
		if i < len(m.MacAddress) {
			x = uint8(m.MacAddress[i])
		}
		buf[pos] = uint8(x)
		pos += 1
	}
	// field[1] m.DataQuota
	o.PutUint64(buf[pos:pos+8], uint64(m.DataQuota))
	pos += 8
	// field[1] m.DataUsedInRange
	o.PutUint64(buf[pos:pos+8], uint64(m.DataUsedInRange))
	pos += 8
	// field[1] m.Flags
	o.PutUint32(buf[pos:pos+4], uint32(m.Flags))
	pos += 4
	// field[1] m.DeviceName
	copy(buf[pos:pos+64], m.DeviceName)
	pos += 64
	// field[1] m.Nranges
	o.PutUint32(buf[pos:pos+4], uint32(len(m.Ranges)))
	pos += 4
	// field[1] m.Ranges
	for j1 := 0; j1 < len(m.Ranges); j1++ {
		var v1 MactimeTimeRange
		if j1 < len(m.Ranges) {
			v1 = m.Ranges[j1]
		}
		// field[2] v1.Start
		o.PutUint64(buf[pos:pos+8], math.Float64bits(float64(v1.Start)))
		pos += 8
		// field[2] v1.End
		o.PutUint64(buf[pos:pos+8], math.Float64bits(float64(v1.End)))
		pos += 8
	}
	return buf, nil
}
func (m *MactimeDetails) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.PoolIndex
	m.PoolIndex = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	// field[1] m.MacAddress
	for i := 0; i < len(m.MacAddress); i++ {
		m.MacAddress[i] = uint8(tmp[pos])
		pos += 1
	}
	// field[1] m.DataQuota
	m.DataQuota = uint64(o.Uint64(tmp[pos : pos+8]))
	pos += 8
	// field[1] m.DataUsedInRange
	m.DataUsedInRange = uint64(o.Uint64(tmp[pos : pos+8]))
	pos += 8
	// field[1] m.Flags
	m.Flags = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	// field[1] m.DeviceName
	{
		nul := bytes.Index(tmp[pos:pos+64], []byte{0x00})
		m.DeviceName = codec.DecodeString(tmp[pos : pos+nul])
		pos += 64
	}
	// field[1] m.Nranges
	m.Nranges = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	// field[1] m.Ranges
	m.Ranges = make([]MactimeTimeRange, int(m.Nranges))
	for j1 := 0; j1 < int(m.Nranges); j1++ {
		// field[2] m.Ranges[j1].Start
		m.Ranges[j1].Start = float64(math.Float64frombits(o.Uint64(tmp[pos : pos+8])))
		pos += 8
		// field[2] m.Ranges[j1].End
		m.Ranges[j1].End = float64(math.Float64frombits(o.Uint64(tmp[pos : pos+8])))
		pos += 8
	}
	return nil
}

// MactimeDump represents VPP binary API message 'mactime_dump'.
type MactimeDump struct {
	MyTableEpoch uint32 `binapi:"u32,name=my_table_epoch" json:"my_table_epoch,omitempty"`
}

func (m *MactimeDump) Reset()                        { *m = MactimeDump{} }
func (*MactimeDump) GetMessageName() string          { return "mactime_dump" }
func (*MactimeDump) GetCrcString() string            { return "8f454e23" }
func (*MactimeDump) GetMessageType() api.MessageType { return api.RequestMessage }

func (m *MactimeDump) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.MyTableEpoch
	size += 4
	return size
}
func (m *MactimeDump) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.MyTableEpoch
	o.PutUint32(buf[pos:pos+4], uint32(m.MyTableEpoch))
	pos += 4
	return buf, nil
}
func (m *MactimeDump) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.MyTableEpoch
	m.MyTableEpoch = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	return nil
}

// MactimeDumpReply represents VPP binary API message 'mactime_dump_reply'.
type MactimeDumpReply struct {
	Retval     int32  `binapi:"i32,name=retval" json:"retval,omitempty"`
	TableEpoch uint32 `binapi:"u32,name=table_epoch" json:"table_epoch,omitempty"`
}

func (m *MactimeDumpReply) Reset()                        { *m = MactimeDumpReply{} }
func (*MactimeDumpReply) GetMessageName() string          { return "mactime_dump_reply" }
func (*MactimeDumpReply) GetCrcString() string            { return "49bcc753" }
func (*MactimeDumpReply) GetMessageType() api.MessageType { return api.ReplyMessage }

func (m *MactimeDumpReply) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.Retval
	size += 4
	// field[1] m.TableEpoch
	size += 4
	return size
}
func (m *MactimeDumpReply) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.Retval
	o.PutUint32(buf[pos:pos+4], uint32(m.Retval))
	pos += 4
	// field[1] m.TableEpoch
	o.PutUint32(buf[pos:pos+4], uint32(m.TableEpoch))
	pos += 4
	return buf, nil
}
func (m *MactimeDumpReply) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.Retval
	m.Retval = int32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	// field[1] m.TableEpoch
	m.TableEpoch = uint32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	return nil
}

// MactimeEnableDisable represents VPP binary API message 'mactime_enable_disable'.
type MactimeEnableDisable struct {
	EnableDisable bool                           `binapi:"bool,name=enable_disable" json:"enable_disable,omitempty"`
	SwIfIndex     interface_types.InterfaceIndex `binapi:"interface_index,name=sw_if_index" json:"sw_if_index,omitempty"`
}

func (m *MactimeEnableDisable) Reset()                        { *m = MactimeEnableDisable{} }
func (*MactimeEnableDisable) GetMessageName() string          { return "mactime_enable_disable" }
func (*MactimeEnableDisable) GetCrcString() string            { return "3865946c" }
func (*MactimeEnableDisable) GetMessageType() api.MessageType { return api.RequestMessage }

func (m *MactimeEnableDisable) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.EnableDisable
	size += 1
	// field[1] m.SwIfIndex
	size += 4
	return size
}
func (m *MactimeEnableDisable) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.EnableDisable
	if m.EnableDisable {
		buf[pos] = 1
	}
	pos += 1
	// field[1] m.SwIfIndex
	o.PutUint32(buf[pos:pos+4], uint32(m.SwIfIndex))
	pos += 4
	return buf, nil
}
func (m *MactimeEnableDisable) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.EnableDisable
	m.EnableDisable = tmp[pos] != 0
	pos += 1
	// field[1] m.SwIfIndex
	m.SwIfIndex = interface_types.InterfaceIndex(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	return nil
}

// MactimeEnableDisableReply represents VPP binary API message 'mactime_enable_disable_reply'.
type MactimeEnableDisableReply struct {
	Retval int32 `binapi:"i32,name=retval" json:"retval,omitempty"`
}

func (m *MactimeEnableDisableReply) Reset()                        { *m = MactimeEnableDisableReply{} }
func (*MactimeEnableDisableReply) GetMessageName() string          { return "mactime_enable_disable_reply" }
func (*MactimeEnableDisableReply) GetCrcString() string            { return "e8d4e804" }
func (*MactimeEnableDisableReply) GetMessageType() api.MessageType { return api.ReplyMessage }

func (m *MactimeEnableDisableReply) Size() int {
	if m == nil {
		return 0
	}
	var size int
	// field[1] m.Retval
	size += 4
	return size
}
func (m *MactimeEnableDisableReply) Marshal(b []byte) ([]byte, error) {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	var buf []byte
	if b == nil {
		buf = make([]byte, m.Size())
	} else {
		buf = b
	}
	// field[1] m.Retval
	o.PutUint32(buf[pos:pos+4], uint32(m.Retval))
	pos += 4
	return buf, nil
}
func (m *MactimeEnableDisableReply) Unmarshal(tmp []byte) error {
	o := binary.BigEndian
	_ = o
	pos := 0
	_ = pos
	// field[1] m.Retval
	m.Retval = int32(o.Uint32(tmp[pos : pos+4]))
	pos += 4
	return nil
}

func init() { file_mactime_binapi_init() }
func file_mactime_binapi_init() {
	api.RegisterMessage((*MactimeAddDelRange)(nil), "mactime.MactimeAddDelRange")
	api.RegisterMessage((*MactimeAddDelRangeReply)(nil), "mactime.MactimeAddDelRangeReply")
	api.RegisterMessage((*MactimeDetails)(nil), "mactime.MactimeDetails")
	api.RegisterMessage((*MactimeDump)(nil), "mactime.MactimeDump")
	api.RegisterMessage((*MactimeDumpReply)(nil), "mactime.MactimeDumpReply")
	api.RegisterMessage((*MactimeEnableDisable)(nil), "mactime.MactimeEnableDisable")
	api.RegisterMessage((*MactimeEnableDisableReply)(nil), "mactime.MactimeEnableDisableReply")
}

// Messages returns list of all messages in this module.
func AllMessages() []api.Message {
	return []api.Message{
		(*MactimeAddDelRange)(nil),
		(*MactimeAddDelRangeReply)(nil),
		(*MactimeDetails)(nil),
		(*MactimeDump)(nil),
		(*MactimeDumpReply)(nil),
		(*MactimeEnableDisable)(nil),
		(*MactimeEnableDisableReply)(nil),
	}
}

// Reference imports to suppress errors if they are not otherwise used.
var _ = api.RegisterMessage
var _ = codec.DecodeString
var _ = bytes.NewBuffer
var _ = context.Background
var _ = io.Copy
var _ = strconv.Itoa
var _ = strings.Contains
var _ = struc.Pack
var _ = binary.BigEndian
var _ = math.Float32bits
var _ = net.ParseIP
var _ = fmt.Errorf
